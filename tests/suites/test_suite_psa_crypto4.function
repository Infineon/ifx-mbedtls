/* BEGIN_HEADER */
#include <stdint.h>

#include "mbedtls/asn1.h"
#include "mbedtls/asn1write.h"
#include "mbedtls/oid.h"
#include "common.h"

/* For MBEDTLS_CTR_DRBG_MAX_REQUEST, knowing that psa_generate_random()
 * uses mbedtls_ctr_drbg internally. */
#include "mbedtls/ctr_drbg.h"

#include "psa/crypto.h"
#include "psa_crypto_slot_management.h"

/* For psa_can_do_hash() */
#include "psa_crypto_core.h"

#include "test/asn1_helpers.h"
#include "test/psa_crypto_helpers.h"
#include "test/psa_exercise_key.h"
#if defined(PSA_CRYPTO_DRIVER_TEST)
#include "test/drivers/test_driver.h"
#define TEST_DRIVER_LOCATION PSA_CRYPTO_TEST_DRIVER_LOCATION
#else
#define TEST_DRIVER_LOCATION 0x7fffff
#endif

/* If this comes up, it's a bug in the test code or in the test data. */
#define UNUSED 0xdeadbeef

/* Assert that an operation is (not) active.
 * This serves as a proxy for checking if the operation is aborted. */
#define ASSERT_OPERATION_IS_ACTIVE(operation) TEST_ASSERT(operation.id != 0)
#define ASSERT_OPERATION_IS_INACTIVE(operation) TEST_ASSERT(operation.id == 0)

#if defined(PSA_WANT_ALG_JPAKE)
int ecjpake_operation_setup(psa_pake_operation_t *operation,
                            psa_pake_cipher_suite_t *cipher_suite,
                            psa_pake_role_t role,
                            mbedtls_svc_key_id_t key,
                            size_t key_available)
{
    PSA_ASSERT(psa_pake_abort(operation));

    PSA_ASSERT(psa_pake_setup(operation, cipher_suite));

    PSA_ASSERT(psa_pake_set_role(operation, role));

    if (key_available) {
        PSA_ASSERT(psa_pake_set_password_key(operation, key));
    }
    return 0;
exit:
    return 1;
}
#endif

/** An invalid export length that will never be set by psa_export_key(). */
static const size_t INVALID_EXPORT_LENGTH = ~0U;

int exercise_mac_setup(psa_key_type_t key_type,
                       const unsigned char *key_bytes,
                       size_t key_length,
                       psa_algorithm_t alg,
                       psa_mac_operation_t *operation,
                       psa_status_t *status)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_HASH);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);
    PSA_ASSERT(psa_import_key(&attributes, key_bytes, key_length, &key));

    *status = psa_mac_sign_setup(operation, key, alg);
    /* Whether setup succeeded or failed, abort must succeed. */
    PSA_ASSERT(psa_mac_abort(operation));
    /* If setup failed, reproduce the failure, so that the caller can
     * test the resulting state of the operation object. */
    if (*status != PSA_SUCCESS) {
        TEST_EQUAL(psa_mac_sign_setup(operation, key, alg), *status);
    }

    psa_destroy_key(key);
    return 1;

exit:
    psa_destroy_key(key);
    return 0;
}

int exercise_cipher_setup(psa_key_type_t key_type,
                          const unsigned char *key_bytes,
                          size_t key_length,
                          psa_algorithm_t alg,
                          psa_cipher_operation_t *operation,
                          psa_status_t *status)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);
    PSA_ASSERT(psa_import_key(&attributes, key_bytes, key_length, &key));

    *status = psa_cipher_encrypt_setup(operation, key, alg);
    /* Whether setup succeeded or failed, abort must succeed. */
    PSA_ASSERT(psa_cipher_abort(operation));
    /* If setup failed, reproduce the failure, so that the caller can
     * test the resulting state of the operation object. */
    if (*status != PSA_SUCCESS) {
        TEST_EQUAL(psa_cipher_encrypt_setup(operation, key, alg),
                   *status);
    }

    psa_destroy_key(key);
    return 1;

exit:
    psa_destroy_key(key);
    return 0;
}

static int test_operations_on_invalid_key(mbedtls_svc_key_id_t key)
{
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    mbedtls_svc_key_id_t key_id = mbedtls_svc_key_id_make(1, 0x6964);
    uint8_t buffer[1];
    size_t length;
    int ok = 0;

    psa_set_key_id(&attributes, key_id);
    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    psa_set_key_algorithm(&attributes, PSA_ALG_CTR);
    psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    TEST_EQUAL(psa_get_key_attributes(key, &attributes),
               PSA_ERROR_INVALID_HANDLE);
    TEST_EQUAL(
        MBEDTLS_SVC_KEY_ID_GET_KEY_ID(psa_get_key_id(&attributes)), 0);
    TEST_EQUAL(
        MBEDTLS_SVC_KEY_ID_GET_OWNER_ID(psa_get_key_id(&attributes)), 0);
    TEST_EQUAL(psa_get_key_lifetime(&attributes), 0);
    TEST_EQUAL(psa_get_key_usage_flags(&attributes), 0);
    TEST_EQUAL(psa_get_key_algorithm(&attributes), 0);
    TEST_EQUAL(psa_get_key_type(&attributes), 0);
    TEST_EQUAL(psa_get_key_bits(&attributes), 0);

    TEST_EQUAL(psa_export_key(key, buffer, sizeof(buffer), &length),
               PSA_ERROR_INVALID_HANDLE);
    TEST_EQUAL(psa_export_public_key(key,
                                     buffer, sizeof(buffer), &length),
               PSA_ERROR_INVALID_HANDLE);

    ok = 1;

exit:
    /*
     * Key attributes may have been returned by psa_get_key_attributes()
     * thus reset them as required.
     */
    psa_reset_key_attributes(&attributes);

    return ok;
}

/* Assert that a key isn't reported as having a slot number. */
#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
#define ASSERT_NO_SLOT_NUMBER(attributes)                             \
    do                                                                  \
    {                                                                   \
        psa_key_slot_number_t ASSERT_NO_SLOT_NUMBER_slot_number;        \
        TEST_EQUAL(psa_get_key_slot_number(                            \
                       attributes,                                     \
                       &ASSERT_NO_SLOT_NUMBER_slot_number),           \
                   PSA_ERROR_INVALID_ARGUMENT);                       \
    }                                                                   \
    while (0)
#else /* MBEDTLS_PSA_CRYPTO_SE_C */
#define ASSERT_NO_SLOT_NUMBER(attributes)     \
    ((void) 0)
#endif /* MBEDTLS_PSA_CRYPTO_SE_C */

#define INPUT_INTEGER 0x10000   /* Out of range of psa_key_type_t */

/* An overapproximation of the amount of storage needed for a key of the
 * given type and with the given content. The API doesn't make it easy
 * to find a good value for the size. The current implementation doesn't
 * care about the value anyway. */
#define KEY_BITS_FROM_DATA(type, data)        \
    (data)->len

typedef enum {
    IMPORT_KEY = 0,
    GENERATE_KEY = 1,
    DERIVE_KEY = 2
} generate_method;

typedef enum {
    DO_NOT_SET_LENGTHS = 0,
    SET_LENGTHS_BEFORE_NONCE = 1,
    SET_LENGTHS_AFTER_NONCE = 2
} set_lengths_method_t;

typedef enum {
    USE_NULL_TAG = 0,
    USE_GIVEN_TAG = 1,
} tag_usage_method_t;


/*!
 * \brief                           Internal Function for AEAD multipart tests.
 * \param key_type_arg              Type of key passed in
 * \param key_data                  The encryption / decryption key data
 * \param alg_arg                   The type of algorithm used
 * \param nonce                     Nonce data
 * \param additional_data           Additional data
 * \param ad_part_len_arg           If not -1, the length of chunks to
 *                                  feed additional data in to be encrypted /
 *                                  decrypted. If -1, no chunking.
 * \param input_data                Data to encrypt / decrypt
 * \param data_part_len_arg         If not -1, the length of chunks to feed
 *                                  the data in to be encrypted / decrypted. If
 *                                  -1, no chunking
 * \param set_lengths_method        A member of the set_lengths_method_t enum is
 *                                  expected here, this controls whether or not
 *                                  to set lengths, and in what order with
 *                                  respect to set nonce.
 * \param expected_output           Expected output
 * \param is_encrypt                If non-zero this is an encryption operation.
 * \param do_zero_parts             If non-zero, interleave zero length chunks
 *                                  with normal length chunks.
 * \return int                      Zero on failure, non-zero on success.
 */
static int aead_multipart_internal_func(int key_type_arg, data_t *key_data,
                                        int alg_arg,
                                        data_t *nonce,
                                        data_t *additional_data,
                                        int ad_part_len_arg,
                                        data_t *input_data,
                                        int data_part_len_arg,
                                        set_lengths_method_t set_lengths_method,
                                        data_t *expected_output,
                                        int is_encrypt,
                                        int do_zero_parts)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
    unsigned char *output_data = NULL;
    unsigned char *part_data = NULL;
    unsigned char *final_data = NULL;
    size_t data_true_size = 0;
    size_t part_data_size = 0;
    size_t output_size = 0;
    size_t final_output_size = 0;
    size_t output_length = 0;
    size_t key_bits = 0;
    size_t tag_length = 0;
    size_t part_offset = 0;
    size_t part_length = 0;
    size_t output_part_length = 0;
    size_t tag_size = 0;
    size_t ad_part_len = 0;
    size_t data_part_len = 0;
    uint8_t tag_buffer[PSA_AEAD_TAG_MAX_SIZE];
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;

    int test_ok = 0;
    size_t part_count = 0;

    PSA_ASSERT(psa_crypto_init());

    if (is_encrypt) {
        psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    } else {
        psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
    }

    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));

    PSA_ASSERT(psa_get_key_attributes(key, &attributes));
    key_bits = psa_get_key_bits(&attributes);

    tag_length = PSA_AEAD_TAG_LENGTH(key_type, key_bits, alg);

    if (is_encrypt) {
        /* Tag gets written at end of buffer. */
        output_size = PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg,
                                                  (input_data->len +
                                                   tag_length));
        data_true_size = input_data->len;
    } else {
        output_size = PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg,
                                                  (input_data->len -
                                                   tag_length));

        /* Do not want to attempt to decrypt tag. */
        data_true_size = input_data->len - tag_length;
    }

    TEST_CALLOC(output_data, output_size);

    if (is_encrypt) {
        final_output_size = PSA_AEAD_FINISH_OUTPUT_SIZE(key_type, alg);
        TEST_LE_U(final_output_size, PSA_AEAD_FINISH_OUTPUT_MAX_SIZE);
    } else {
        final_output_size = PSA_AEAD_VERIFY_OUTPUT_SIZE(key_type, alg);
        TEST_LE_U(final_output_size, PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE);
    }

    TEST_CALLOC(final_data, final_output_size);

    if (is_encrypt) {
        status = psa_aead_encrypt_setup(&operation, key, alg);
    } else {
        status = psa_aead_decrypt_setup(&operation, key, alg);
    }

    /* If the operation is not supported, just skip and not fail in case the
     * encryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce->len);
    }

    PSA_ASSERT(status);

    if (set_lengths_method ==  DO_NOT_SET_LENGTHS) {
        PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));
    } else if (set_lengths_method == SET_LENGTHS_BEFORE_NONCE) {
        PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                        data_true_size));
        PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));
    } else if (set_lengths_method ==  SET_LENGTHS_AFTER_NONCE) {
        PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

        PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                        data_true_size));
    }

    if (ad_part_len_arg != -1) {
        /* Pass additional data in parts */
        ad_part_len = (size_t) ad_part_len_arg;

        for (part_offset = 0, part_count = 0;
             part_offset < additional_data->len;
             part_offset += part_length, part_count++) {
            if (do_zero_parts && (part_count & 0x01)) {
                part_length = 0;
            } else if (additional_data->len - part_offset < ad_part_len) {
                part_length = additional_data->len - part_offset;
            } else {
                part_length = ad_part_len;
            }

            PSA_ASSERT(psa_aead_update_ad(&operation,
                                          additional_data->x + part_offset,
                                          part_length));

        }
    } else {
        /* Pass additional data in one go. */
        PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                      additional_data->len));
    }

    if (data_part_len_arg != -1) {
        /* Pass data in parts */
        data_part_len = (size_t) data_part_len_arg;
        part_data_size = PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg,
                                                     (size_t) data_part_len);

        TEST_CALLOC(part_data, part_data_size);

        for (part_offset = 0, part_count = 0;
             part_offset < data_true_size;
             part_offset += part_length, part_count++) {
            if (do_zero_parts && (part_count & 0x01)) {
                part_length = 0;
            } else if ((data_true_size - part_offset) < data_part_len) {
                part_length = (data_true_size - part_offset);
            } else {
                part_length = data_part_len;
            }

            PSA_ASSERT(psa_aead_update(&operation,
                                       (input_data->x + part_offset),
                                       part_length, part_data,
                                       part_data_size,
                                       &output_part_length));

            if (output_data && output_part_length) {
                memcpy((output_data + output_length), part_data,
                       output_part_length);
            }

            output_length += output_part_length;
        }
    } else {
        /* Pass all data in one go. */
        PSA_ASSERT(psa_aead_update(&operation, input_data->x,
                                   data_true_size, output_data,
                                   output_size, &output_length));
    }

    if (is_encrypt) {
        PSA_ASSERT(psa_aead_finish(&operation, final_data,
                                   final_output_size,
                                   &output_part_length,
                                   tag_buffer, tag_length,
                                   &tag_size));
    } else {
        PSA_ASSERT(psa_aead_verify(&operation, final_data,
                                   final_output_size,
                                   &output_part_length,
                                   (input_data->x + data_true_size),
                                   tag_length));
    }

    if (output_data && output_part_length) {
        memcpy((output_data + output_length), final_data,
               output_part_length);
    }

    output_length += output_part_length;


    /* For all currently defined algorithms, PSA_AEAD_xxx_OUTPUT_SIZE
     * should be exact.*/
    if (is_encrypt) {
        TEST_EQUAL(tag_length, tag_size);

        if (output_data && tag_length) {
            memcpy((output_data + output_length), tag_buffer,
                   tag_length);
        }

        output_length += tag_length;

        TEST_EQUAL(output_length,
                   PSA_AEAD_ENCRYPT_OUTPUT_SIZE(key_type, alg,
                                                input_data->len));
        TEST_LE_U(output_length,
                  PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(input_data->len));
    } else {
        TEST_EQUAL(output_length,
                   PSA_AEAD_DECRYPT_OUTPUT_SIZE(key_type, alg,
                                                input_data->len));
        TEST_LE_U(output_length,
                  PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(input_data->len));
    }


    TEST_MEMORY_COMPARE(expected_output->x, expected_output->len,
                        output_data, output_length);


    test_ok = 1;

exit:
    psa_destroy_key(key);
    psa_aead_abort(&operation);
    mbedtls_free(output_data);
    mbedtls_free(part_data);
    mbedtls_free(final_data);
    PSA_DONE();

    return test_ok;
}

typedef enum {
    INJECT_ERR_NONE = 0,
    INJECT_ERR_UNINITIALIZED_ACCESS,
    INJECT_ERR_DUPLICATE_SETUP,
    INJECT_ERR_INVALID_USER,
    INJECT_ERR_INVALID_PEER,
    INJECT_ERR_SET_USER,
    INJECT_ERR_SET_PEER,
    INJECT_EMPTY_IO_BUFFER,
    INJECT_UNKNOWN_STEP,
    INJECT_INVALID_FIRST_STEP,
    INJECT_WRONG_BUFFER_SIZE,
    INJECT_VALID_OPERATION_AFTER_FAILURE,
    INJECT_ANTICIPATE_KEY_DERIVATION_1,
    INJECT_ANTICIPATE_KEY_DERIVATION_2,
} ecjpake_injected_failure_t;

#if defined(MBEDTLS_ECP_RESTARTABLE)

static void interruptible_signverify_get_minmax_completes(uint32_t max_ops,
                                                          psa_status_t expected_status,
                                                          size_t *min_completes,
                                                          size_t *max_completes)
{

    /* This is slightly contrived, but we only really know that with a minimum
       value of max_ops that a successful operation should take more than one op
       to complete, and likewise that with a max_ops of
       PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, it should complete in one go. */
    if (max_ops == 0 || max_ops == 1) {

        if (expected_status == PSA_SUCCESS) {
            *min_completes = 2;
        } else {
            *min_completes = 1;
        }

        *max_completes = PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED;
    } else {
        *min_completes = 1;
        *max_completes = 1;
    }
}
#endif /* MBEDTLS_ECP_RESTARTABLE */

/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_PSA_CRYPTO_C
 * END_DEPENDENCIES
 */


/* BEGIN_CASE */
void aead_encrypt_decrypt(int key_type_arg, data_t *key_data,
                          int alg_arg,
                          data_t *nonce,
                          data_t *additional_data,
                          data_t *input_data,
                          int expected_result_arg)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    size_t key_bits;
    unsigned char *output_data = NULL;
    size_t output_size = 0;
    size_t output_length = 0;
    unsigned char *output_data2 = NULL;
    size_t output_length2 = 0;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    psa_status_t expected_result = expected_result_arg;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));
    PSA_ASSERT(psa_get_key_attributes(key, &attributes));
    key_bits = psa_get_key_bits(&attributes);

    output_size = input_data->len + PSA_AEAD_TAG_LENGTH(key_type, key_bits,
                                                        alg);
    /* For all currently defined algorithms, PSA_AEAD_ENCRYPT_OUTPUT_SIZE
     * should be exact. */
    if (expected_result != PSA_ERROR_INVALID_ARGUMENT &&
        expected_result != PSA_ERROR_NOT_SUPPORTED) {
        TEST_EQUAL(output_size,
                   PSA_AEAD_ENCRYPT_OUTPUT_SIZE(key_type, alg, input_data->len));
        TEST_LE_U(output_size,
                  PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(input_data->len));
    }
    TEST_CALLOC(output_data, output_size);

    status = psa_aead_encrypt(key, alg,
                              nonce->x, nonce->len,
                              additional_data->x,
                              additional_data->len,
                              input_data->x, input_data->len,
                              output_data, output_size,
                              &output_length);

    /* If the operation is not supported, just skip and not fail in case the
     * encryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce->len);
    }

    TEST_EQUAL(status, expected_result);

    if (PSA_SUCCESS == expected_result) {
        TEST_CALLOC(output_data2, output_length);

        /* For all currently defined algorithms, PSA_AEAD_DECRYPT_OUTPUT_SIZE
         * should be exact. */
        TEST_EQUAL(input_data->len,
                   PSA_AEAD_DECRYPT_OUTPUT_SIZE(key_type, alg, output_length));

        TEST_LE_U(input_data->len,
                  PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(output_length));

        TEST_EQUAL(psa_aead_decrypt(key, alg,
                                    nonce->x, nonce->len,
                                    additional_data->x,
                                    additional_data->len,
                                    output_data, output_length,
                                    output_data2, output_length,
                                    &output_length2),
                   expected_result);

        TEST_MEMORY_COMPARE(input_data->x, input_data->len,
                            output_data2, output_length2);
    }

exit:
    psa_destroy_key(key);
    mbedtls_free(output_data);
    mbedtls_free(output_data2);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_encrypt(int key_type_arg, data_t *key_data,
                  int alg_arg,
                  data_t *nonce,
                  data_t *additional_data,
                  data_t *input_data,
                  data_t *expected_result)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    size_t key_bits;
    unsigned char *output_data = NULL;
    size_t output_size = 0;
    size_t output_length = 0;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));
    PSA_ASSERT(psa_get_key_attributes(key, &attributes));
    key_bits = psa_get_key_bits(&attributes);

    output_size = input_data->len + PSA_AEAD_TAG_LENGTH(key_type, key_bits,
                                                        alg);
    /* For all currently defined algorithms, PSA_AEAD_ENCRYPT_OUTPUT_SIZE
     * should be exact. */
    TEST_EQUAL(output_size,
               PSA_AEAD_ENCRYPT_OUTPUT_SIZE(key_type, alg, input_data->len));
    TEST_LE_U(output_size,
              PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(input_data->len));
    TEST_CALLOC(output_data, output_size);

    status = psa_aead_encrypt(key, alg,
                              nonce->x, nonce->len,
                              additional_data->x, additional_data->len,
                              input_data->x, input_data->len,
                              output_data, output_size,
                              &output_length);

    /* If the operation is not supported, just skip and not fail in case the
     * encryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce->len);
    }

    PSA_ASSERT(status);
    TEST_MEMORY_COMPARE(expected_result->x, expected_result->len,
                        output_data, output_length);

exit:
    psa_destroy_key(key);
    mbedtls_free(output_data);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_decrypt(int key_type_arg, data_t *key_data,
                  int alg_arg,
                  data_t *nonce,
                  data_t *additional_data,
                  data_t *input_data,
                  data_t *expected_data,
                  int expected_result_arg)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    size_t key_bits;
    unsigned char *output_data = NULL;
    size_t output_size = 0;
    size_t output_length = 0;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t expected_result = expected_result_arg;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));
    PSA_ASSERT(psa_get_key_attributes(key, &attributes));
    key_bits = psa_get_key_bits(&attributes);

    output_size = input_data->len - PSA_AEAD_TAG_LENGTH(key_type, key_bits,
                                                        alg);
    if (expected_result != PSA_ERROR_INVALID_ARGUMENT &&
        expected_result != PSA_ERROR_NOT_SUPPORTED) {
        /* For all currently defined algorithms, PSA_AEAD_DECRYPT_OUTPUT_SIZE
         * should be exact. */
        TEST_EQUAL(output_size,
                   PSA_AEAD_DECRYPT_OUTPUT_SIZE(key_type, alg, input_data->len));
        TEST_LE_U(output_size,
                  PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(input_data->len));
    }
    TEST_CALLOC(output_data, output_size);

    status = psa_aead_decrypt(key, alg,
                              nonce->x, nonce->len,
                              additional_data->x,
                              additional_data->len,
                              input_data->x, input_data->len,
                              output_data, output_size,
                              &output_length);

    /* If the operation is not supported, just skip and not fail in case the
     * decryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce->len);
    }

    TEST_EQUAL(status, expected_result);

    if (expected_result == PSA_SUCCESS) {
        TEST_MEMORY_COMPARE(expected_data->x, expected_data->len,
                            output_data, output_length);
    }

exit:
    psa_destroy_key(key);
    mbedtls_free(output_data);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_encrypt(int key_type_arg, data_t *key_data,
                            int alg_arg,
                            data_t *nonce,
                            data_t *additional_data,
                            data_t *input_data,
                            int do_set_lengths,
                            data_t *expected_output)
{
    size_t ad_part_len = 0;
    size_t data_part_len = 0;
    set_lengths_method_t set_lengths_method = DO_NOT_SET_LENGTHS;

    for (ad_part_len = 1; ad_part_len <= additional_data->len; ad_part_len++) {
        mbedtls_test_set_step(ad_part_len);

        if (do_set_lengths) {
            if (ad_part_len & 0x01) {
                set_lengths_method = SET_LENGTHS_AFTER_NONCE;
            } else {
                set_lengths_method = SET_LENGTHS_BEFORE_NONCE;
            }
        }

        /* Split ad into length(ad_part_len) parts. */
        if (!aead_multipart_internal_func(key_type_arg, key_data,
                                          alg_arg, nonce,
                                          additional_data,
                                          ad_part_len,
                                          input_data, -1,
                                          set_lengths_method,
                                          expected_output,
                                          1, 0)) {
            break;
        }

        /* length(0) part, length(ad_part_len) part, length(0) part... */
        mbedtls_test_set_step(1000 + ad_part_len);

        if (!aead_multipart_internal_func(key_type_arg, key_data,
                                          alg_arg, nonce,
                                          additional_data,
                                          ad_part_len,
                                          input_data, -1,
                                          set_lengths_method,
                                          expected_output,
                                          1, 1)) {
            break;
        }
    }

    for (data_part_len = 1; data_part_len <= input_data->len; data_part_len++) {
        /* Split data into length(data_part_len) parts. */
        mbedtls_test_set_step(2000 + data_part_len);

        if (do_set_lengths) {
            if (data_part_len & 0x01) {
                set_lengths_method = SET_LENGTHS_AFTER_NONCE;
            } else {
                set_lengths_method = SET_LENGTHS_BEFORE_NONCE;
            }
        }

        if (!aead_multipart_internal_func(key_type_arg, key_data,
                                          alg_arg, nonce,
                                          additional_data, -1,
                                          input_data, data_part_len,
                                          set_lengths_method,
                                          expected_output,
                                          1, 0)) {
            break;
        }

        /* length(0) part, length(data_part_len) part, length(0) part... */
        mbedtls_test_set_step(3000 + data_part_len);

        if (!aead_multipart_internal_func(key_type_arg, key_data,
                                          alg_arg, nonce,
                                          additional_data, -1,
                                          input_data, data_part_len,
                                          set_lengths_method,
                                          expected_output,
                                          1, 1)) {
            break;
        }
    }

    /* Goto is required to silence warnings about unused labels, as we
     * don't actually do any test assertions in this function. */
    goto exit;
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_decrypt(int key_type_arg, data_t *key_data,
                            int alg_arg,
                            data_t *nonce,
                            data_t *additional_data,
                            data_t *input_data,
                            int do_set_lengths,
                            data_t *expected_output)
{
    size_t ad_part_len = 0;
    size_t data_part_len = 0;
    set_lengths_method_t set_lengths_method = DO_NOT_SET_LENGTHS;

    for (ad_part_len = 1; ad_part_len <= additional_data->len; ad_part_len++) {
        /* Split ad into length(ad_part_len) parts. */
        mbedtls_test_set_step(ad_part_len);

        if (do_set_lengths) {
            if (ad_part_len & 0x01) {
                set_lengths_method = SET_LENGTHS_AFTER_NONCE;
            } else {
                set_lengths_method = SET_LENGTHS_BEFORE_NONCE;
            }
        }

        if (!aead_multipart_internal_func(key_type_arg, key_data,
                                          alg_arg, nonce,
                                          additional_data,
                                          ad_part_len,
                                          input_data, -1,
                                          set_lengths_method,
                                          expected_output,
                                          0, 0)) {
            break;
        }

        /* length(0) part, length(ad_part_len) part, length(0) part... */
        mbedtls_test_set_step(1000 + ad_part_len);

        if (!aead_multipart_internal_func(key_type_arg, key_data,
                                          alg_arg, nonce,
                                          additional_data,
                                          ad_part_len,
                                          input_data, -1,
                                          set_lengths_method,
                                          expected_output,
                                          0, 1)) {
            break;
        }
    }

    for (data_part_len = 1; data_part_len <= input_data->len; data_part_len++) {
        /* Split data into length(data_part_len) parts. */
        mbedtls_test_set_step(2000 + data_part_len);

        if (do_set_lengths) {
            if (data_part_len & 0x01) {
                set_lengths_method = SET_LENGTHS_AFTER_NONCE;
            } else {
                set_lengths_method = SET_LENGTHS_BEFORE_NONCE;
            }
        }

        if (!aead_multipart_internal_func(key_type_arg, key_data,
                                          alg_arg, nonce,
                                          additional_data, -1,
                                          input_data, data_part_len,
                                          set_lengths_method,
                                          expected_output,
                                          0, 0)) {
            break;
        }

        /* length(0) part, length(data_part_len) part, length(0) part... */
        mbedtls_test_set_step(3000 + data_part_len);

        if (!aead_multipart_internal_func(key_type_arg, key_data,
                                          alg_arg, nonce,
                                          additional_data, -1,
                                          input_data, data_part_len,
                                          set_lengths_method,
                                          expected_output,
                                          0, 1)) {
            break;
        }
    }

    /* Goto is required to silence warnings about unused labels, as we
     * don't actually do any test assertions in this function. */
    goto exit;
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_verify(int key_type_arg, data_t *key_data,
                           int alg_arg,
                           data_t *nonce,
                           data_t *additional_data,
                           data_t *input_data,
                           data_t *tag,
                           int tag_usage_arg,
                           int expected_setup_status_arg,
                           int expected_status_arg)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    psa_status_t expected_status = expected_status_arg;
    psa_status_t expected_setup_status = expected_setup_status_arg;
    unsigned char *plaintext = NULL;
    unsigned char *finish_plaintext = NULL;
    size_t plaintext_size = 0;
    size_t plaintext_length = 0;
    size_t verify_plaintext_size = 0;
    tag_usage_method_t tag_usage = tag_usage_arg;
    unsigned char *tag_buffer = NULL;
    size_t tag_size = 0;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));

    PSA_ASSERT(psa_get_key_attributes(key, &attributes));

    plaintext_size = PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg,
                                                 input_data->len);

    TEST_CALLOC(plaintext, plaintext_size);

    verify_plaintext_size = PSA_AEAD_VERIFY_OUTPUT_SIZE(key_type, alg);

    TEST_CALLOC(finish_plaintext, verify_plaintext_size);

    status = psa_aead_decrypt_setup(&operation, key, alg);

    /* If the operation is not supported, just skip and not fail in case the
     * encryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce->len);
    }
    TEST_EQUAL(status, expected_setup_status);

    if (status != PSA_SUCCESS) {
        goto exit;
    }

    PSA_ASSERT(status);

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    status = psa_aead_set_lengths(&operation, additional_data->len,
                                  input_data->len);
    PSA_ASSERT(status);

    PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len));

    PSA_ASSERT(psa_aead_update(&operation, input_data->x,
                               input_data->len,
                               plaintext, plaintext_size,
                               &plaintext_length));

    if (tag_usage == USE_GIVEN_TAG) {
        tag_buffer = tag->x;
        tag_size = tag->len;
    }

    status = psa_aead_verify(&operation, finish_plaintext,
                             verify_plaintext_size,
                             &plaintext_length,
                             tag_buffer, tag_size);

    TEST_EQUAL(status, expected_status);

exit:
    psa_destroy_key(key);
    mbedtls_free(plaintext);
    mbedtls_free(finish_plaintext);
    psa_aead_abort(&operation);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_generate_nonce(int key_type_arg, data_t *key_data,
                                   int alg_arg,
                                   int nonce_length,
                                   int expected_nonce_length_arg,
                                   data_t *additional_data,
                                   data_t *input_data,
                                   int expected_status_arg)
{

    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
    /* Some tests try to get more than the maximum nonce length,
     * so allocate double. */
    uint8_t nonce_buffer[PSA_AEAD_NONCE_MAX_SIZE * 2];
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    psa_status_t expected_status = expected_status_arg;
    size_t actual_nonce_length = 0;
    size_t expected_nonce_length = expected_nonce_length_arg;
    unsigned char *output = NULL;
    unsigned char *ciphertext = NULL;
    size_t output_size = 0;
    size_t ciphertext_size = 0;
    size_t ciphertext_length = 0;
    size_t tag_length = 0;
    uint8_t tag_buffer[PSA_AEAD_TAG_MAX_SIZE];

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));

    PSA_ASSERT(psa_get_key_attributes(key, &attributes));

    output_size = PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg, input_data->len);

    TEST_CALLOC(output, output_size);

    ciphertext_size = PSA_AEAD_FINISH_OUTPUT_SIZE(key_type, alg);

    TEST_LE_U(ciphertext_size, PSA_AEAD_FINISH_OUTPUT_MAX_SIZE);

    TEST_CALLOC(ciphertext, ciphertext_size);

    status = psa_aead_encrypt_setup(&operation, key, alg);

    /* If the operation is not supported, just skip and not fail in case the
     * encryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce_length);
    }

    PSA_ASSERT(status);

    status = psa_aead_generate_nonce(&operation, nonce_buffer,
                                     nonce_length,
                                     &actual_nonce_length);

    TEST_EQUAL(status, expected_status);

    TEST_EQUAL(actual_nonce_length, expected_nonce_length);

    if (expected_status == PSA_SUCCESS) {
        TEST_EQUAL(actual_nonce_length, PSA_AEAD_NONCE_LENGTH(key_type,
                                                              alg));
    }

    TEST_LE_U(actual_nonce_length, PSA_AEAD_NONCE_MAX_SIZE);

    if (expected_status == PSA_SUCCESS) {
        /* Ensure we can still complete operation. */
        PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                        input_data->len));

        PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                      additional_data->len));

        PSA_ASSERT(psa_aead_update(&operation, input_data->x, input_data->len,
                                   output, output_size,
                                   &ciphertext_length));

        PSA_ASSERT(psa_aead_finish(&operation, ciphertext, ciphertext_size,
                                   &ciphertext_length, tag_buffer,
                                   PSA_AEAD_TAG_MAX_SIZE, &tag_length));
    }

exit:
    psa_destroy_key(key);
    mbedtls_free(output);
    mbedtls_free(ciphertext);
    psa_aead_abort(&operation);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_set_nonce(int key_type_arg, data_t *key_data,
                              int alg_arg,
                              int nonce_length_arg,
                              int set_lengths_method_arg,
                              data_t *additional_data,
                              data_t *input_data,
                              int expected_status_arg)
{

    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
    uint8_t *nonce_buffer = NULL;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    psa_status_t expected_status = expected_status_arg;
    unsigned char *output = NULL;
    unsigned char *ciphertext = NULL;
    size_t nonce_length;
    size_t output_size = 0;
    size_t ciphertext_size = 0;
    size_t ciphertext_length = 0;
    size_t tag_length = 0;
    uint8_t tag_buffer[PSA_AEAD_TAG_MAX_SIZE];
    size_t index = 0;
    set_lengths_method_t set_lengths_method = set_lengths_method_arg;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));

    PSA_ASSERT(psa_get_key_attributes(key, &attributes));

    output_size = PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg, input_data->len);

    TEST_CALLOC(output, output_size);

    ciphertext_size = PSA_AEAD_FINISH_OUTPUT_SIZE(key_type, alg);

    TEST_LE_U(ciphertext_size, PSA_AEAD_FINISH_OUTPUT_MAX_SIZE);

    TEST_CALLOC(ciphertext, ciphertext_size);

    status = psa_aead_encrypt_setup(&operation, key, alg);

    /* If the operation is not supported, just skip and not fail in case the
     * encryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce_length_arg);
    }

    PSA_ASSERT(status);

    /* -1 == zero length and valid buffer, 0 = zero length and NULL buffer. */
    if (nonce_length_arg == -1) {
        /* Arbitrary size buffer, to test zero length valid buffer. */
        TEST_CALLOC(nonce_buffer, 4);
        nonce_length = 0;
    } else {
        /* If length is zero, then this will return NULL. */
        nonce_length = (size_t) nonce_length_arg;
        TEST_CALLOC(nonce_buffer, nonce_length);

        if (nonce_buffer) {
            for (index = 0; index < nonce_length - 1; ++index) {
                nonce_buffer[index] = 'a' + index;
            }
        }
    }

    if (set_lengths_method == SET_LENGTHS_BEFORE_NONCE) {
        PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                        input_data->len));
    }

    status = psa_aead_set_nonce(&operation, nonce_buffer, nonce_length);

    TEST_EQUAL(status, expected_status);

    if (expected_status == PSA_SUCCESS) {
        if (set_lengths_method == SET_LENGTHS_AFTER_NONCE) {
            PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                            input_data->len));
        }
        if (operation.alg == PSA_ALG_CCM && set_lengths_method == DO_NOT_SET_LENGTHS) {
            expected_status = PSA_ERROR_BAD_STATE;
        }

        /* Ensure we can still complete operation, unless it's CCM and we didn't set lengths. */
        TEST_EQUAL(psa_aead_update_ad(&operation, additional_data->x,
                                      additional_data->len),
                   expected_status);

        TEST_EQUAL(psa_aead_update(&operation, input_data->x, input_data->len,
                                   output, output_size,
                                   &ciphertext_length),
                   expected_status);

        TEST_EQUAL(psa_aead_finish(&operation, ciphertext, ciphertext_size,
                                   &ciphertext_length, tag_buffer,
                                   PSA_AEAD_TAG_MAX_SIZE, &tag_length),
                   expected_status);
    }

exit:
    psa_destroy_key(key);
    mbedtls_free(output);
    mbedtls_free(ciphertext);
    mbedtls_free(nonce_buffer);
    psa_aead_abort(&operation);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_update_buffer_test(int key_type_arg, data_t *key_data,
                                       int alg_arg,
                                       int output_size_arg,
                                       data_t *nonce,
                                       data_t *additional_data,
                                       data_t *input_data,
                                       int expected_status_arg)
{

    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    psa_status_t expected_status = expected_status_arg;
    unsigned char *output = NULL;
    unsigned char *ciphertext = NULL;
    size_t output_size = output_size_arg;
    size_t ciphertext_size = 0;
    size_t ciphertext_length = 0;
    size_t tag_length = 0;
    uint8_t tag_buffer[PSA_AEAD_TAG_MAX_SIZE];

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));

    PSA_ASSERT(psa_get_key_attributes(key, &attributes));

    TEST_CALLOC(output, output_size);

    ciphertext_size = PSA_AEAD_FINISH_OUTPUT_SIZE(key_type, alg);

    TEST_CALLOC(ciphertext, ciphertext_size);

    status = psa_aead_encrypt_setup(&operation, key, alg);

    /* If the operation is not supported, just skip and not fail in case the
     * encryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce->len);
    }

    PSA_ASSERT(status);

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len));

    status = psa_aead_update(&operation, input_data->x, input_data->len,
                             output, output_size, &ciphertext_length);

    TEST_EQUAL(status, expected_status);

    if (expected_status == PSA_SUCCESS) {
        /* Ensure we can still complete operation. */
        PSA_ASSERT(psa_aead_finish(&operation, ciphertext, ciphertext_size,
                                   &ciphertext_length, tag_buffer,
                                   PSA_AEAD_TAG_MAX_SIZE, &tag_length));
    }

exit:
    psa_destroy_key(key);
    mbedtls_free(output);
    mbedtls_free(ciphertext);
    psa_aead_abort(&operation);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_finish_buffer_test(int key_type_arg, data_t *key_data,
                                       int alg_arg,
                                       int finish_ciphertext_size_arg,
                                       int tag_size_arg,
                                       data_t *nonce,
                                       data_t *additional_data,
                                       data_t *input_data,
                                       int expected_status_arg)
{

    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    psa_status_t expected_status = expected_status_arg;
    unsigned char *ciphertext = NULL;
    unsigned char *finish_ciphertext = NULL;
    unsigned char *tag_buffer = NULL;
    size_t ciphertext_size = 0;
    size_t ciphertext_length = 0;
    size_t finish_ciphertext_size = (size_t) finish_ciphertext_size_arg;
    size_t tag_size = (size_t) tag_size_arg;
    size_t tag_length = 0;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));

    PSA_ASSERT(psa_get_key_attributes(key, &attributes));

    ciphertext_size = PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg, input_data->len);

    TEST_CALLOC(ciphertext, ciphertext_size);

    TEST_CALLOC(finish_ciphertext, finish_ciphertext_size);

    TEST_CALLOC(tag_buffer, tag_size);

    status = psa_aead_encrypt_setup(&operation, key, alg);

    /* If the operation is not supported, just skip and not fail in case the
     * encryption involves a common limitation of cryptography hardwares and
     * an alternative implementation. */
    if (status == PSA_ERROR_NOT_SUPPORTED) {
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_AES_192(key_type, key_data->len * 8);
        MBEDTLS_TEST_PSA_SKIP_IF_ALT_GCM_NOT_12BYTES_NONCE(alg, nonce->len);
    }

    PSA_ASSERT(status);

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len));

    PSA_ASSERT(psa_aead_update(&operation, input_data->x, input_data->len,
                               ciphertext, ciphertext_size, &ciphertext_length));

    /* Ensure we can still complete operation. */
    status = psa_aead_finish(&operation, finish_ciphertext,
                             finish_ciphertext_size,
                             &ciphertext_length, tag_buffer,
                             tag_size, &tag_length);

    TEST_EQUAL(status, expected_status);

exit:
    psa_destroy_key(key);
    mbedtls_free(ciphertext);
    mbedtls_free(finish_ciphertext);
    mbedtls_free(tag_buffer);
    psa_aead_abort(&operation);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_setup(int key_type_arg, data_t *key_data,
                          int alg_arg, int expected_status_arg)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    psa_status_t expected_status = expected_status_arg;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes,
                            PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));

    status = psa_aead_encrypt_setup(&operation, key, alg);

    TEST_EQUAL(status, expected_status);

    psa_aead_abort(&operation);

    status = psa_aead_decrypt_setup(&operation, key, alg);

    TEST_EQUAL(status, expected_status);

exit:
    psa_destroy_key(key);
    psa_aead_abort(&operation);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void aead_multipart_state_test(int key_type_arg, data_t *key_data,
                               int alg_arg,
                               data_t *nonce,
                               data_t *additional_data,
                               data_t *input_data)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t key_type = key_type_arg;
    psa_algorithm_t alg = alg_arg;
    psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
    unsigned char *output_data = NULL;
    unsigned char *final_data = NULL;
    size_t output_size = 0;
    size_t finish_output_size = 0;
    size_t output_length = 0;
    size_t key_bits = 0;
    size_t tag_length = 0;
    size_t tag_size = 0;
    size_t nonce_length = 0;
    uint8_t nonce_buffer[PSA_AEAD_NONCE_MAX_SIZE];
    uint8_t tag_buffer[PSA_AEAD_TAG_MAX_SIZE];
    size_t output_part_length = 0;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes,
                            PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, key_type);

    PSA_ASSERT(psa_import_key(&attributes, key_data->x, key_data->len,
                              &key));

    PSA_ASSERT(psa_get_key_attributes(key, &attributes));
    key_bits = psa_get_key_bits(&attributes);

    tag_length = PSA_AEAD_TAG_LENGTH(key_type, key_bits, alg);

    TEST_LE_U(tag_length, PSA_AEAD_TAG_MAX_SIZE);

    output_size = PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg, input_data->len);

    TEST_CALLOC(output_data, output_size);

    finish_output_size = PSA_AEAD_FINISH_OUTPUT_SIZE(key_type, alg);

    TEST_LE_U(finish_output_size, PSA_AEAD_FINISH_OUTPUT_MAX_SIZE);

    TEST_CALLOC(final_data, finish_output_size);

    /* Test all operations error without calling setup first. */

    TEST_EQUAL(psa_aead_set_nonce(&operation, nonce->x, nonce->len),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    TEST_EQUAL(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    TEST_EQUAL(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    TEST_EQUAL(psa_aead_update(&operation, input_data->x,
                               input_data->len, output_data,
                               output_size, &output_length),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    TEST_EQUAL(psa_aead_finish(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer, tag_length,
                               &tag_size),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    TEST_EQUAL(psa_aead_verify(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer,
                               tag_length),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test for double setups. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_encrypt_setup(&operation, key, alg),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_decrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_decrypt_setup(&operation, key, alg),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_decrypt_setup(&operation, key, alg),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_decrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_encrypt_setup(&operation, key, alg),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test for not setting a nonce. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_update(&operation, input_data->x,
                               input_data->len, output_data,
                               output_size, &output_length),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_finish(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer, tag_length,
                               &tag_size),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_decrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_verify(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer,
                               tag_length),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test for double setting nonce. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    TEST_EQUAL(psa_aead_set_nonce(&operation, nonce->x, nonce->len),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test for double generating nonce. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length));

    TEST_EQUAL(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length),
               PSA_ERROR_BAD_STATE);


    psa_aead_abort(&operation);

    /* Test for generate nonce then set and vice versa */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length));

    TEST_EQUAL(psa_aead_set_nonce(&operation, nonce->x, nonce->len),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test for generating nonce after calling set lengths */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length));

    psa_aead_abort(&operation);

    /* Test for generating nonce after calling set lengths with UINT32_MAX ad_data length */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    if (operation.alg == PSA_ALG_CCM) {
        TEST_EQUAL(psa_aead_set_lengths(&operation, UINT32_MAX,
                                        input_data->len),
                   PSA_ERROR_INVALID_ARGUMENT);
        TEST_EQUAL(psa_aead_generate_nonce(&operation, nonce_buffer,
                                           PSA_AEAD_NONCE_MAX_SIZE,
                                           &nonce_length),
                   PSA_ERROR_BAD_STATE);
    } else {
        PSA_ASSERT(psa_aead_set_lengths(&operation, UINT32_MAX,
                                        input_data->len));
        PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                           PSA_AEAD_NONCE_MAX_SIZE,
                                           &nonce_length));
    }

    psa_aead_abort(&operation);

    /* Test for generating nonce after calling set lengths with SIZE_MAX ad_data length */
#if SIZE_MAX > UINT32_MAX
    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    if (operation.alg == PSA_ALG_CCM || operation.alg == PSA_ALG_GCM) {
        TEST_EQUAL(psa_aead_set_lengths(&operation, SIZE_MAX,
                                        input_data->len),
                   PSA_ERROR_INVALID_ARGUMENT);
        TEST_EQUAL(psa_aead_generate_nonce(&operation, nonce_buffer,
                                           PSA_AEAD_NONCE_MAX_SIZE,
                                           &nonce_length),
                   PSA_ERROR_BAD_STATE);
    } else {
        PSA_ASSERT(psa_aead_set_lengths(&operation, SIZE_MAX,
                                        input_data->len));
        PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                           PSA_AEAD_NONCE_MAX_SIZE,
                                           &nonce_length));
    }

    psa_aead_abort(&operation);
#endif

    /* Test for calling set lengths with a UINT32_MAX ad_data length, after generating nonce */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length));

    if (operation.alg == PSA_ALG_CCM) {
        TEST_EQUAL(psa_aead_set_lengths(&operation, UINT32_MAX,
                                        input_data->len),
                   PSA_ERROR_INVALID_ARGUMENT);
    } else {
        PSA_ASSERT(psa_aead_set_lengths(&operation, UINT32_MAX,
                                        input_data->len));
    }

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */
    /* Test for setting nonce after calling set lengths */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    psa_aead_abort(&operation);

    /* Test for setting nonce after calling set lengths with UINT32_MAX ad_data length */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    if (operation.alg == PSA_ALG_CCM) {
        TEST_EQUAL(psa_aead_set_lengths(&operation, UINT32_MAX,
                                        input_data->len),
                   PSA_ERROR_INVALID_ARGUMENT);
        TEST_EQUAL(psa_aead_set_nonce(&operation, nonce->x, nonce->len),
                   PSA_ERROR_BAD_STATE);
    } else {
        PSA_ASSERT(psa_aead_set_lengths(&operation, UINT32_MAX,
                                        input_data->len));
        PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));
    }

    psa_aead_abort(&operation);

    /* Test for setting nonce after calling set lengths with SIZE_MAX ad_data length */
#if SIZE_MAX > UINT32_MAX
    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    if (operation.alg == PSA_ALG_CCM || operation.alg == PSA_ALG_GCM) {
        TEST_EQUAL(psa_aead_set_lengths(&operation, SIZE_MAX,
                                        input_data->len),
                   PSA_ERROR_INVALID_ARGUMENT);
        TEST_EQUAL(psa_aead_set_nonce(&operation, nonce->x, nonce->len),
                   PSA_ERROR_BAD_STATE);
    } else {
        PSA_ASSERT(psa_aead_set_lengths(&operation, SIZE_MAX,
                                        input_data->len));
        PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));
    }

    psa_aead_abort(&operation);
#endif

    /* Test for calling set lengths with an ad_data length of UINT32_MAX, after setting nonce */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    if (operation.alg == PSA_ALG_CCM) {
        TEST_EQUAL(psa_aead_set_lengths(&operation, UINT32_MAX,
                                        input_data->len),
                   PSA_ERROR_INVALID_ARGUMENT);
    } else {
        PSA_ASSERT(psa_aead_set_lengths(&operation, UINT32_MAX,
                                        input_data->len));
    }

    psa_aead_abort(&operation);

    /* Test for setting nonce after calling set lengths with plaintext length of SIZE_MAX */
#if SIZE_MAX > UINT32_MAX
    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    if (operation.alg == PSA_ALG_GCM) {
        TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                        SIZE_MAX),
                   PSA_ERROR_INVALID_ARGUMENT);
        TEST_EQUAL(psa_aead_set_nonce(&operation, nonce->x, nonce->len),
                   PSA_ERROR_BAD_STATE);
    } else if (operation.alg != PSA_ALG_CCM) {
        PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                        SIZE_MAX));
        PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));
    }

    psa_aead_abort(&operation);
#endif

    /* Test for calling set lengths with a plaintext length of SIZE_MAX, after setting nonce */
#if SIZE_MAX > UINT32_MAX
    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    if (operation.alg == PSA_ALG_GCM) {
        TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                        SIZE_MAX),
                   PSA_ERROR_INVALID_ARGUMENT);
    } else if (operation.alg != PSA_ALG_CCM) {
        PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                        SIZE_MAX));
    }

    psa_aead_abort(&operation);
#endif

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    TEST_EQUAL(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test for generating nonce in decrypt setup. */

    PSA_ASSERT(psa_aead_decrypt_setup(&operation, key, alg));

    TEST_EQUAL(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test for setting lengths twice. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test for setting lengths after setting nonce + already starting data. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    if (operation.alg == PSA_ALG_CCM) {

        TEST_EQUAL(psa_aead_update_ad(&operation, additional_data->x,
                                      additional_data->len),
                   PSA_ERROR_BAD_STATE);
    } else {
        PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                      additional_data->len));

        TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                        input_data->len),
                   PSA_ERROR_BAD_STATE);
    }
    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    if (operation.alg == PSA_ALG_CCM) {
        TEST_EQUAL(psa_aead_update(&operation, input_data->x,
                                   input_data->len, output_data,
                                   output_size, &output_length),
                   PSA_ERROR_BAD_STATE);

    } else {
        PSA_ASSERT(psa_aead_update(&operation, input_data->x,
                                   input_data->len, output_data,
                                   output_size, &output_length));

        TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                        input_data->len),
                   PSA_ERROR_BAD_STATE);
    }
    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    if (operation.alg == PSA_ALG_CCM) {
        PSA_ASSERT(psa_aead_finish(&operation, final_data,
                                   finish_output_size,
                                   &output_part_length,
                                   tag_buffer, tag_length,
                                   &tag_size));
    } else {
        PSA_ASSERT(psa_aead_finish(&operation, final_data,
                                   finish_output_size,
                                   &output_part_length,
                                   tag_buffer, tag_length,
                                   &tag_size));

        TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                        input_data->len),
                   PSA_ERROR_BAD_STATE);
    }
    psa_aead_abort(&operation);

    /* Test for setting lengths after generating nonce + already starting data. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length));
    if (operation.alg == PSA_ALG_CCM) {

        TEST_EQUAL(psa_aead_update_ad(&operation, additional_data->x,
                                      additional_data->len),
                   PSA_ERROR_BAD_STATE);
    } else {
        PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                      additional_data->len));

        TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                        input_data->len),
                   PSA_ERROR_BAD_STATE);
    }
    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length));
    if (operation.alg == PSA_ALG_CCM) {
        TEST_EQUAL(psa_aead_update(&operation, input_data->x,
                                   input_data->len, output_data,
                                   output_size, &output_length),
                   PSA_ERROR_BAD_STATE);

    } else {
        PSA_ASSERT(psa_aead_update(&operation, input_data->x,
                                   input_data->len, output_data,
                                   output_size, &output_length));

        TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                        input_data->len),
                   PSA_ERROR_BAD_STATE);
    }
    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_generate_nonce(&operation, nonce_buffer,
                                       PSA_AEAD_NONCE_MAX_SIZE,
                                       &nonce_length));
    if (operation.alg == PSA_ALG_CCM) {
        PSA_ASSERT(psa_aead_finish(&operation, final_data,
                                   finish_output_size,
                                   &output_part_length,
                                   tag_buffer, tag_length,
                                   &tag_size));
    } else {
        PSA_ASSERT(psa_aead_finish(&operation, final_data,
                                   finish_output_size,
                                   &output_part_length,
                                   tag_buffer, tag_length,
                                   &tag_size));

        TEST_EQUAL(psa_aead_set_lengths(&operation, additional_data->len,
                                        input_data->len),
                   PSA_ERROR_BAD_STATE);
    }
    psa_aead_abort(&operation);

    /* Test for not sending any additional data or data after setting non zero
     * lengths for them. (encrypt) */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    TEST_EQUAL(psa_aead_finish(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer, tag_length,
                               &tag_size),
               PSA_ERROR_INVALID_ARGUMENT);

    psa_aead_abort(&operation);

    /* Test for not sending any additional data or data after setting non-zero
     * lengths for them. (decrypt) */

    PSA_ASSERT(psa_aead_decrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    TEST_EQUAL(psa_aead_verify(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer,
                               tag_length),
               PSA_ERROR_INVALID_ARGUMENT);

    psa_aead_abort(&operation);

    /* Test for not sending any additional data after setting a non-zero length
     * for it. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    TEST_EQUAL(psa_aead_update(&operation, input_data->x,
                               input_data->len, output_data,
                               output_size, &output_length),
               PSA_ERROR_INVALID_ARGUMENT);

    psa_aead_abort(&operation);

    /* Test for not sending any data after setting a non-zero length for it.*/

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len));

    TEST_EQUAL(psa_aead_finish(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer, tag_length,
                               &tag_size),
               PSA_ERROR_INVALID_ARGUMENT);

    psa_aead_abort(&operation);

    /* Test for sending too much additional data after setting lengths. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, 0, 0));


    TEST_EQUAL(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len),
               PSA_ERROR_INVALID_ARGUMENT);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len));

    TEST_EQUAL(psa_aead_update_ad(&operation, additional_data->x,
                                  1),
               PSA_ERROR_INVALID_ARGUMENT);

    psa_aead_abort(&operation);

    /* Test for sending too much data after setting lengths. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, 0, 0));

    TEST_EQUAL(psa_aead_update(&operation, input_data->x,
                               input_data->len, output_data,
                               output_size, &output_length),
               PSA_ERROR_INVALID_ARGUMENT);

    psa_aead_abort(&operation);

    /* ------------------------------------------------------- */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    PSA_ASSERT(psa_aead_set_lengths(&operation, additional_data->len,
                                    input_data->len));

    PSA_ASSERT(psa_aead_update_ad(&operation, additional_data->x,
                                  additional_data->len));

    PSA_ASSERT(psa_aead_update(&operation, input_data->x,
                               input_data->len, output_data,
                               output_size, &output_length));

    TEST_EQUAL(psa_aead_update(&operation, input_data->x,
                               1, output_data,
                               output_size, &output_length),
               PSA_ERROR_INVALID_ARGUMENT);

    psa_aead_abort(&operation);

    /* Test sending additional data after data. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    if (operation.alg != PSA_ALG_CCM) {
        PSA_ASSERT(psa_aead_update(&operation, input_data->x,
                                   input_data->len, output_data,
                                   output_size, &output_length));

        TEST_EQUAL(psa_aead_update_ad(&operation, additional_data->x,
                                      additional_data->len),
                   PSA_ERROR_BAD_STATE);
    }
    psa_aead_abort(&operation);

    /* Test calling finish on decryption. */

    PSA_ASSERT(psa_aead_decrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    TEST_EQUAL(psa_aead_finish(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer, tag_length,
                               &tag_size),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);

    /* Test calling verify on encryption. */

    PSA_ASSERT(psa_aead_encrypt_setup(&operation, key, alg));

    PSA_ASSERT(psa_aead_set_nonce(&operation, nonce->x, nonce->len));

    TEST_EQUAL(psa_aead_verify(&operation, final_data,
                               finish_output_size,
                               &output_part_length,
                               tag_buffer,
                               tag_length),
               PSA_ERROR_BAD_STATE);

    psa_aead_abort(&operation);


exit:
    psa_destroy_key(key);
    psa_aead_abort(&operation);
    mbedtls_free(output_data);
    mbedtls_free(final_data);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void signature_size(int type_arg,
                    int bits,
                    int alg_arg,
                    int expected_size_arg)
{
    psa_key_type_t type = type_arg;
    psa_algorithm_t alg = alg_arg;
    size_t actual_size = PSA_SIGN_OUTPUT_SIZE(type, bits, alg);

    TEST_EQUAL(actual_size, (size_t) expected_size_arg);

exit:
    ;
}
/* END_CASE */

/* BEGIN_CASE */
void import_and_exercise_key(data_t *data,
                             int type_arg,
                             int bits_arg,
                             int alg_arg)
{
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_type_t type = type_arg;
    size_t bits = bits_arg;
    psa_algorithm_t alg = alg_arg;
    psa_key_usage_t usage = mbedtls_test_psa_usage_to_exercise(type, alg);
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_key_attributes_t got_attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_ASSERT(psa_crypto_init());

    psa_set_key_usage_flags(&attributes, usage);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, type);

    /* Import the key */
    PSA_ASSERT(psa_import_key(&attributes, data->x, data->len, &key));

    /* Test the key information */
    PSA_ASSERT(psa_get_key_attributes(key, &got_attributes));
    TEST_EQUAL(psa_get_key_type(&got_attributes), type);
    TEST_EQUAL(psa_get_key_bits(&got_attributes), bits);

    /* Do something with the key according to its type and permitted usage. */
    if (!mbedtls_test_psa_exercise_key(key, usage, alg, 0)) {
        goto exit;
    }

    PSA_ASSERT(psa_destroy_key(key));
    test_operations_on_invalid_key(key);

exit:
    /*
     * Key attributes may have been returned by psa_get_key_attributes()
     * thus reset them as required.
     */
    psa_reset_key_attributes(&got_attributes);

    psa_reset_key_attributes(&attributes);
    psa_destroy_key(key);
    PSA_DONE();
}
/* END_CASE */

